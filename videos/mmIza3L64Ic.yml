# Editing guidelines: https://github.com/watch-devtube/contrib/#how-to-edit-video-metadata

category: conference
tags:
    - containers
    - security
    - java
    - spring
title: 'Webinar: Building WebSocket Browser Applications with Spring'
recordingDate: 1382552975
description: "Speaker: Rossen Stoyanchev\nSlides: https:/github.com/rstoyanchev/webinar-websocket-spring\nCode: https://github.com/rstoyanchev/spring-websocket-portfolio\nSo, you've written a \"Hello world!\" WebSocket application or perhaps even a chat sample. You're able to exchange messages even in pre-Servlet 3.1 containers and pre-IE 10 browsers (that don't yet support WebSocket) thanks to the SockJS protocol and Spring's support for it. However a message is a blank page that can have any content. Whatever message format you choose, proprietary or standard, both client and server need to understand it as well as distinguish different kinds of messages. You need support for the publish-subscribe pattern central to messaging applications so you can broadcast messages to one or more subscribers. You need to incorporate security, validation, and so on. In short you need to build a real-world application. If you're used to web applications (and Spring MVC annotated controllers) you are familiar with the foundation that HTTP provides including URLs (nouns), HTTP methods (verbs), headers, parameters, and others. Imagine building an application without HTTP, just a socket. WebSocket gives you this brand new, exciting capability -- full duplex, two-way communication -- yet you no longer have an application-level protocol. Can an entire application be built around a single Endpoint class processing all messages, assuming a single WebSocket connection between browser and server? Join Rossen Stoyanchev as he demonstrates that, thankfully, the WebSocket protocol has a built-in sub-protocol mechanism."

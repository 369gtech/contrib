# Contribution guide: https://github.com/watch-devtube/contrib

# speaker:
#   name: _____
#   twitter: _____ # mandatory twitter handle; must not include @

# tags: [____, _____, _____]

tags:
    - architecture
title: 'Piotr Wyczesany -- O co chodzi z tym całym "Domain-Driven Design"?'
recordingDate: 1394181027
description: "Bio:\n\nPierwszą linijkę kodu napisał gdzieś w 1993 roku. Od tego czasu wiele się zmieniło w świecie software developmentu, ale wielu z nas tego jeszcze nie zauważyło. ;)\n\nProfesjonalnie tworzy software w Javie od 2005 roku. W tym czasie zdążył pracować w małych firmach, korporacjach, oraz zaliczyć epizod z własnym startupem. Od kilkunastu miesięcy aktywnie interesuje się tematami modelowania złożonych dziedzin biznesowych (Domain-Driven Design), o których pisze m.in na swoim blogu : http://www.eventuallyinconsistent.com.\n\nJest założycielem grupy DDD-KRK, oraz aktywnym członkiem SCKRK i SSEPP, a także inicjatorem i organizatorem Krakowskich spotkań przy piwie z cyklu #cqrsbeers. Mieszka i pracuje w Krakowie.\n\n\nPrezentacja:\nO co chodzi z tym całym \"Domain-Driven Design\"?\nJęzyk: PL\n\nWydaje Ci się, że znasz OOP, ale Twój kod przypomina spaghetti? Czy Twoja architektura pomaga, czy też może przeszkadza Ci w pracy nad Twoim systemem? Słyszałeś o złożoności esencjonalnej i przypadkowej, ale nie wiesz jak skupić się na tej pierwszej?\n\n\"Domain-Driven Design\" to podejście do tworzenia oprogramowania, które całościowo wspomaga tworzenie złożonych systemów IT -- zarówno na poziomie architektury, jak i kodu. Można je wykorzystywać w każdym języku i w połączeniu z dowolnym frameworkiem. Być może słyszałeś, że w DDD chodzi o Agregaty, Encje i Value Objecty. Być może wydaje Ci się, że to jest jakaś nisza dla garstki pasjonatów. Być może uważasz, że u Ciebie to się nie sprawdzi. Być może uważasz, że wszystko da się napisać przy pomocy Anemicznych Encji z getterami i setterami, oraz Serwisu. Być może jesteś w błędzie...\n\nW ramach prezentacji dowiesz się czym jest Domena, oraz jej Model. Zobaczysz jakie architektury można wykorzystywać. Poznasz jakie paradygmaty programowania można zastosować do implementacji Modelu na poziomie kodu. Ostatecznie możesz przeżyć szok, dowiadując się, że OOP jakiego używasz na co dzień, może nie mieć wiele wspólnego z prawdziwym paradygmatem obiektowym."

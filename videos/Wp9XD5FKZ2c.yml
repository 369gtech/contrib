# Contribution guide: https://github.com/watch-devtube/contrib

# speaker:
#   name: _____
#   twitter: _____ # mandatory twitter handle; must not include @

# tags: [____, _____, _____]

tags:
    - unix
title: 'Q&A with Programming Language Beta Users'
recordingDate: 1607236458
description: "0:00 Introduction\n2:20 Roadmap for the next few Beta releases\n3:30 Upcoming module handling improvements\n18:53 Upcoming default metaprogram improvements\n23:40 Start of the Beta user Q&A\n25:50 I can see that you can change the allocator on a context by changing an allocator (a function) and allocation_data. For allocators that allow individual allocations to be returned how do you specify the equivalent of free() to the context? Or don't you?\n31:14 How do you configure the compiler to build a Jai library for use on Android/ARM64?\n33:53 What made you shrink the compiler team back to just yourself?\n43:46 How are you feeling about how the beta is progressing? Do you have an idea of how many more times you want to expand the closed beta, or roughly when it might go into open?\n46:43 Would you prefer us to report bugs asap, or wait and bundle up a few at a time?\n47:46 I like the monorepo/project approach for modularity, does it conflict with your earlier statement that compilers/languages are underspecified in many regards? Should metaprogramming fill all those gaps?\n50:09 Why not closures? What are the alternatives to closures? What can we do in the language that is equivalent to what closures provide?\n56:34 You often talk about how syntax is not definite right now, is there anything that you are seriously considering changing in the future?\n58:58 As with standard modules, could there be standard metaprogram modules, which could be included to enhance build processes and such, for instance to impose common house rules\n1:01:31 The question of what is standard library vs external stuff keeps coming up; how are you aiming to delineate it? Would a \"batteries included\" approach covering most of the everyday stuff not provide a reasonable amount of value? Relatedly, \"Basic\" is a bad name for a module, as it's fairly arbitrary and different from one person to another what counts as \"Basic\"\n1:05:56 Are there plans to add build-in support for code hotloading for running executable?\n1:07:24 I have a big change for the built-in hotloader module that fixes its totally broken linux part but these fixes need to change the API slightly. Do you want such bigger changes for built-in modules?\n1:15:00 You mentioned that struct literals are new which explains some of my issue but what are your current thoughts on allowing non-constant values for struct literals?\n1:19:00 I couldn't find classic C-style for loops anywhere in the docs, did I miss something?\n1:19:43 Have you thought at all about array-programming?\n1:20:11 Currently, a 'for' loop over an explicit range (e.g. 0..3) disallows use of 'it_index'. Would you consider allowing this in the future? This would reduce friction when, upon code maintenance, the explicit range is replaced with an array whose index needs to be tracked\n1:20:57 Can we get a `sockets` (or `Networking` module)?  Seems like it should be in standard library\n1:21:32 Currently, the single underscore, _, can be used as a variable (like in C). Do you intend for this behavior to endure, or are there plans to change it to function as a blank identifier like in Go?\n1:22:40 Are minor contributions to the existing documentation (like typo fixes and small content additions) welcome?\n1:23:59 To align a big team on a project it proved useful to me to restrict certain features of the language. I understand that I should write a meta-program to fail on features I want to restrict.\n1:24:55 Patrick had a question a couple days ago about trying to modify parameters to functions in a function, in external libraries this is possible but within a Jai program it's not. This confused me a lot early on as well. Perhaps this could be clarified in the how_to's (pass in a pointer...)\n1:27:28 Something slightly confusing is dependencies between metaprograms. When two metaprograms share common namespace that they might both want to change you might get a dependency that doesn't really exist.\n1:29:56 Are there any long-term plans about documentation, in terms of format and scope? I really like the current how_tos. But I imagine there is a large amount of work to do with documenting the distributed modules and language features. Maybe more people could help out with that?\n1:33:14 What plans do you have for extending the procedure/declaration notes stuff? Specifically, I work on a team of ~20 people and issue tracking/project management tools like Jira which are separate to the code are a pain, maybe there's a way the language/metaprogram can help?\n1:37:59 Do you see any places in the type system where things could be added to make robust parallel programming easier?\n1:40:05 Any plans to move the temporary allocator to the context so we can change the way it works if we want to?\n\n(YouTube won't let us paste the rest of this index, short version may come later)."

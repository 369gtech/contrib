# Editing guidelines: https://github.com/watch-devtube/contrib/#how-to-edit-video-metadata


tags:
    - c++
    - performance
    - testing
title: 'CppCon 2017: Sergey Ignatchenko “Ways to Handle Non-blocking Returns in Message-passing Programs...”'
language: English
recordingDate: 1508954080
description: "Eight Ways to Handle Non-blocking Returns in Message-passing Programs: from C++98 via C++11 to C++20\n\nhttp://CppCon.org\n—\nPresentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017\n—\nShared-Nothing approach of \"sharing memory by communicating\" (instead of \"communicating by sharing memory\") gets more and more traction in the development world; this is not to mention that message-passing Shared-Nothing architectures have always been a cornerstone of both game development and UI development. These days, more and more projects realize the inherent dangers of combining business logic and thread sync within the same piece of code - which leads to cognitive overload (pushing developers well over 7+-2 boundary) and results in poor developer productivity, poor program reliability, and very often - subpar performance. In addition, message-passing programs allow to achieve determinism easily, which in turn provides very significant benefits, including such beauties as production post-mortem analysis, replay-based regression testing, and low-latency fault tolerance. \n\nWithin the realm of message-passing programs, the problem of processing non-void returns from non-blocking calls is a particularly ugly one. Over time, approaches to solving it have progressed from simple message-sending to OO-based callbacks, and further to the lambda pyramids and futures. Still, programming non-blocking calls is a Big Headache(tm). In this talk, we'll discuss _eight_ different ways of handling returns from non-blocking calls in the context of message-passing architectures (using event-driven architectures as an all-popular example of message-passing). We'll start with a simplistic message exchange, and will progress to void RPCs, OO-style callbacks, lambda pyramids, single-threaded futures, lambda-based \"code builder\", coroutines/fibers, and co_await. \n\nLast but not least, we'll try to compare these different ways-to-handle-non-blocking-returns from the practical point of view, as well as the ways these eight ways are related to current C++ standard proposals; in addition - I'll argue for two important things-to-keep-in-mind for standard writers and implementors.\n— \nSergey Ignatchenko: ITHare.com \n\nSergey has 20+ years of software development experience, including 15+ years of experience in architectural positions. Among other things, he was a co-architect of a G20 online stock exchange, and a sole architect of a major online game with 400K+ simultaneous players. He's also known for his articles in CUJ, C++ Report, and Overload, as well as for his blog ithare.com; he also spoke at ACCU2010 and ACCU2017, and successfully Kickstarted his upcoming 9-volume book \"Development & Deployment of Multiplayer Online Games\".\n—\nVideos Filmed & Edited by Bash Films: http://www.BashFilms.com"

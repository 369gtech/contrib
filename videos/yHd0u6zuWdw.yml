# Editing guidelines: https://github.com/watch-devtube/contrib/#how-to-edit-video-metadata

category: conference
tags:
    - performance
title: 'Coconut:  COde CONstructing User Tool'
language: English
recordingDate: 1205229129
description: "Google Tech Talks\r\nMarch,  7 2008\r\n\r\nABSTRACT\r\n\r\nCoconut is a developing system for high-assurance, high-performance\r\nsoftware. It was used to develop a library of special functions for\r\nthe Cell BE processor, which is distributed in the Cell BE SDK 3.0 as\r\nMASS. Average performance is 4X better than the alternative\r\nhand-tuned C library, SimdMath.\r\n\r\nCoconut has been successful where patterns of efficient\r\nhardware-specific computation can be captured as higher-order\r\nfunctions and encoded in a Domain Specific Language embedded in\r\nHaskell. Patterns include efficient control structures not\r\nexpressible in C, e.g., the MultiLoop, and efficient uses of SIMD\r\ninstructions which require significant compile-time computation for\r\npattern specialization. Some patterns interact with a novel\r\ninstruction scheduler called Explicitly Staged Software Pipelining,\r\nbased on a min-cut approach, which outperforms SWING modulo scheduling\r\nin our tests.\r\n\r\nA less developed aspect of Coconut is the parallel production of\r\nproofs of correctness along with executables. Current work aims to\r\nprove only limited properties about programs---the ones most likely to\r\nbe broken---creative use of SIMD instructions, and parallelization.\r\nCoconut intermediate code is represented as nested code (hyper)graphs.\r\n At the lowest level, we transform acyclic loop bodies to remove the\r\neffect of SIMDization, and produce machine and/or human readable\r\nspecifications. This has been used to verify opaque patterns of\r\noptimizing linear algebra for SIMD processors.\r\n\r\nSuch code graphs are embedded in higher levels containing control\r\nflow, first single-threaded control flow optimized for ILP, and then\r\nparallel control-flow, optimized to hide communication latency. At\r\nthis level control flow is restricted to allow peak utilization of\r\nmulti-core hardware, but enable efficient compile-time verification of\r\nsoundness. Soundness, in this context, means that the parallelized\r\nprogram can be transformed into a code graph without synchronizing\r\ncontrol flow, because every execution can be shown to produce the same\r\nresult. Think of it as reducing the parallel debugging effort to the\r\nsingle-threaded debugging problem by eliminating the non-determinism\r\ninherent in parallel code. I will give a formal language description\r\nof the language, and the O(n) algorithm which proves soundness and\r\nproduces the equivalent ``single threaded'' code graph.\r\n\r\nSpeaker: Christopher Anand\r\nChristopher Anand is a professor of Computing and Software at McMaster University. His main research areas are software correctness, high performance computation, and automatic code generation. \r\n\r\nHe has also founded the company Optimal Computational Algorithms to provide hardware-specific libraries for scientific applications on novel architectures."
